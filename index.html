<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />

  <title>ãƒãƒ«ã‚¿ãƒ³1900</title>

  <style>
    :root{
      --bd: #ddd;
      --bd-dark: #2a2f3a;
      --bg: #fff;
      --fg: #111;
      --muted: #666;
      --card: #fff;
      --card-dark: #171a21;

      --pill-pad-y: 10px;
      --pill-pad-x: 12px;
      --pill-radius: 999px;

      --btn-radius: 12px;

      /* å¾©ç¿’ç³»ã®æ·¡ã„è‰²ï¼ˆçµ±ä¸€ï¼‰ */
      --review-bg: #f3f6fb;
      --review-bd: #cfd8e3;
      --review-fg: #334155;

      --review-bg-hover: #e9eef7;
      --review-accent: #64748b;

      /* wheel */
      --wheel-item-h: 44px;
      --wheel-radius: 120px;
      --wheel-fade: rgba(255,255,255,0.9);
      --wheel-fade-dark: rgba(15,17,21,0.85);
    }

    body{
      font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      margin: 0;
      padding: 20px;
      background: var(--bg);
      color: var(--fg);
      transition: background .2s ease, color .2s ease;
    }

    .card{
      max-width: 820px;
      margin: 0 auto;
      padding: 18px;
      border: 1px solid var(--bd);
      border-radius: 14px;
      background: var(--card);
      transition: background .2s ease, border-color .2s ease;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top: 10px;
    }

    .badge,
    button.small,
    .pill{
      font-size: 14px;
      line-height: 1;
      padding: var(--pill-pad-y) var(--pill-pad-x);
      border-radius: var(--pill-radius);
      border: 1px solid var(--bd);
      background: transparent;
      color: inherit;
      transition: background .2s ease, border-color .2s ease, color .2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
      white-space: nowrap;
    }

    .pill{ cursor: pointer; }

    button.small{ cursor: pointer; }
    button.small:active{ transform: translateY(1px); }

    .btns{
      display:flex;
      gap:10px;
      margin-top: 16px;
      flex-wrap:wrap;
    }
    button{
      font-size: 18px;
      padding: 12px 14px;
      border-radius: var(--btn-radius);
      border: 1px solid var(--bd);
      background: #fff;
      color: #111;
      cursor: pointer;
      transition: background .2s ease, border-color .2s ease, color .2s ease;
    }
    button:active{ transform: translateY(1px); }

    /* â˜…ä»Šå›ã®ä¿®æ­£ç‚¹ï¼šã‚¢ã‚¤ã‚³ãƒ³ç³»ã ã‘å°‘ã—å¤§ãã */
    button.small.toggle{
      font-size: 18px;
    }

    /* â˜…ã“ã“ã«è¿½åŠ ï¼ˆç™ºéŸ³ãƒœã‚¿ãƒ³ã ã‘å³å¯„ã›ï¼‰ */
    #speakBtn{
      margin-left: auto;
      margin-right: 4px; /* å¾®èª¿æ•´ */
    }

    .primary{ font-weight: 500; }
    .danger{ border-color:#f2c; }
    .toggle{ border-color:#88c; }

    .pill.togglePill{ border-color:#88c; }

    .pill input[type="checkbox"]{
      width:18px;
      height:18px;
      margin:0;
      accent-color: #88c;
      transform: translateY(0.5px);
    }
    .pill .count{
      opacity: .85;
      font-variant-numeric: tabular-nums;
    }

    /* =========================================================
       å¾©ç¿’ç³»UIï¼ˆæ·¡ã„è‰²ã§çµ±ä¸€ï¼‰
       â˜…é‡è¦ï¼šãƒã‚§ãƒƒã‚¯ON/OFFã§èƒŒæ™¯è‰²ã¯å¤‰ãˆãªã„ï¼ˆç†æƒ³ã©ãŠã‚Šï¼‰
       â˜…å¾©ç¿’é–‹å§‹ / å¾©ç¿’ãƒªã‚¹ãƒˆã«è¿½åŠ  / å¾©ç¿’Reset ã«é©ç”¨
    ========================================================= */
    .reviewUI{
      background: var(--review-bg);
      border-color: var(--review-bd);
      color: var(--review-fg);
      border-radius: 14px;
    }

    /* hover ã¯ â€œãƒã‚¦ã‚¹ãŒã‚ã‚‹ç’°å¢ƒã ã‘â€ */
    @media (hover: hover) and (pointer: fine){
      .reviewUI:hover{ background: var(--review-bg-hover); }
    }
    /* ã‚¿ãƒƒãƒç«¯æœ«ã§ã¯ hover ç„¡åŠ¹ï¼ˆiPhoneã§è‰²ãŒæˆ»ã‚‰ãªã„å¯¾ç­–ï¼‰ */
    @media (hover: none){
      .reviewUI:hover{ background: var(--review-bg); }
    }

    /* â˜…æŠ¼ã—ã¦ã„ã‚‹é–“ã ã‘ã€Œç™½ãã™ã‚‹ã€(å¾©ç¿’Resetç”¨) */
    .pressWhite:active{
      background: #fff;
      border-color: var(--review-bd);
      color: var(--review-fg);
    }

    /* iPhoneã§ã€ŒæŠ¼ã—ãŸã‚ã¨è‰²ãŒæ®‹ã‚‹ã€å¯¾ç­–ï¼ˆsticky hoverå¯¾ç­–ã®ä¿é™ºï¼‰
       pressWhite ã¯ hover ã‚’çµ¶å¯¾ã«å¤‰ãˆãªã„ */
    @media (hover: none){
      .pressWhite:hover{ background: var(--review-bg); }
    }

    button, label, .pill{
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .reviewUI input[type="checkbox"]{ accent-color: var(--review-accent); }

    .topbar{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .topbar-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .rangeInput{
      width: 3.5em;
      padding: 6px 8px;
      border: 1px solid var(--bd);
      border-radius: 10px;
      font-size: 14px;
      background: transparent;
      color: inherit;
      text-align: left;
    }

    .rangeStack{
      display:flex;
      align-items: center;
      gap: 10px;
    }

    .word-no{
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      line-height: 1;
      user-select: none;
    }

    .word-num-header{
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      margin-left: 1px;
      line-height: 1;
      user-select: none;
    }

    .displayArea{ min-height: 140px; }

    .word{
      margin: 18px 0 10px;
      line-height: 1.1;
      word-break: break-word;
    }
    .word-text{
      font-size: 30px;
      font-weight: 400;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .meaning{
      font-size: 18px;
      margin: 10px 0 0;
      min-height: 40px;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .missBox{
      display:none;
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid var(--bd);
      border-radius: 12px;
      gap: 10px;
      align-items: center;
      flex-wrap: nowrap;
      width: fit-content;
      max-width: 100%;
      flex: 0 0 auto;
      align-self: flex-start;
      background: rgba(0,0,0,0.02);
    }
    .missBox.show{ display:inline-flex; }
    .missBox input{ width: 22px; height: 22px; margin:0; }
    .missBox .label{ font-size: 16px; user-select: none; white-space: nowrap; display: inline-block;}

    /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ */
    body.dark{
      background: #0f1115;
      color: #e9e9ea;
    }
    body.dark .card{
      background: var(--card-dark);
      border-color: var(--bd-dark);
    }
    body.dark .badge,
    body.dark button.small,
    body.dark .pill{
      border-color: var(--bd-dark);
      background: rgba(255,255,255,0.03);
      color: #d6d6d8;
    }
    body.dark button{
      background: #1f2430;
      border-color: var(--bd-dark);
      color: #e9e9ea;
    }
    body.dark button:hover{ background: #252b3a; }
    body.dark .missBox{
      border-color: var(--bd-dark);
      background: rgba(255,255,255,0.03);
    }
    body.dark .rangeInput{ border-color: var(--bd-dark); }
    body.dark .word-num-header{ color:#aaa; }

    body.dark .reviewUI{
      background: rgba(255,255,255,0.06);
      border-color: var(--bd-dark);
      color: #e5e7eb;
    }

    /* ãƒ€ãƒ¼ã‚¯æ™‚ã® hoverï¼ˆãƒã‚¦ã‚¹æ™‚ã®ã¿ï¼‰ */
    @media (hover: hover) and (pointer: fine){
      body.dark .reviewUI:hover{
        background: rgba(255,255,255,0.10);
      }
    }
    @media (hover: none){
      body.dark .reviewUI:hover{
        background: rgba(255,255,255,0.06);
      }
    }

    /* ãƒ€ãƒ¼ã‚¯æ™‚ï¼šæŠ¼ã—ã¦ã‚‹é–“ã ã‘å°‘ã—æ˜ã‚‹ãï¼ˆçœŸã£ç™½ã¯çœ©ã—ã„ã®ã§ï¼‰ */
    body.dark .pressWhite:active{
      background: rgba(255,255,255,0.16);
      border-color: var(--bd-dark);
      color: #e5e7eb;
    }

    /* iPhoneã®ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æ‹¡å¤§ã‚’èµ·ã“ã—ã«ããã™ã‚‹ */
    button, label, input, .pill{
      touch-action: manipulation;
    }

    /* â˜…ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ« */
    .page-title{
      font-size: 16px;
      font-weight: 700;
      margin: 0 0 12px;
      text-align: center;
      letter-spacing: 0.03em;
    }

    body.dark .page-title{ color: #e9e9ea; }

    /* =========================================================
       ğŸ¡ 3D ãƒ›ã‚¤ãƒ¼ãƒ«ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ï¼‰
    ========================================================= */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: flex-end;
      justify-content: center;
      padding: 14px;
      z-index: 9999;
    }
    .modalOverlay.show{ display:flex; }

    .modalSheet{
      width: min(820px, 100%);
      border-radius: 18px;
      border: 1px solid var(--bd);
      background: #fff;
      color: #111;
      box-shadow: 0 12px 40px rgba(0,0,0,.18);
      overflow: hidden;
      transform: translateY(8px);
      animation: sheetIn .16s ease-out forwards;
    }
    @keyframes sheetIn{
      to{ transform: translateY(0); }
    }
    body.dark .modalSheet{
      background: #171a21;
      color: #e9e9ea;
      border-color: var(--bd-dark);
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }

    .modalHeader{
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--bd);
      gap: 10px;
    }
    body.dark .modalHeader{ border-bottom-color: var(--bd-dark); }

    .modalTitle{
      font-size: 14px;
      font-weight: 700;
      letter-spacing: .02em;
      opacity: .95;
      user-select: none;
    }

    .modalHeader .mini{
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--bd);
      background: transparent;
      color: inherit;
    }
    body.dark .modalHeader .mini{ border-color: var(--bd-dark); background: rgba(255,255,255,0.03); }

    .wheelSearchRow{
      display:flex;
      gap:10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--bd);
    }
    body.dark .wheelSearchRow{ border-bottom-color: var(--bd-dark); }

    .wheelSearch{
      flex: 1;
      border: 1px solid var(--bd);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 16px;
      background: transparent;
      color: inherit;
      outline: none;
    }
    body.dark .wheelSearch{ border-color: var(--bd-dark); }

    .wheelArea{
      position: relative;
      padding: 12px 12px 2px;
    }

    .wheelViewport{
      position: relative;
      height: calc(var(--wheel-item-h) * 7);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: y mandatory;
      overscroll-behavior: contain;
      border-radius: 16px;
      border: 1px solid var(--bd);
      background: rgba(0,0,0,0.02);
      touch-action: pan-y;
    }
    body.dark .wheelViewport{
      border-color: var(--bd-dark);
      background: rgba(255,255,255,0.03);
    }

    /* ä¸Šä¸‹ã®ãƒ•ã‚§ãƒ¼ãƒ‰ï¼ˆãƒ›ã‚¤ãƒ¼ãƒ«æ„Ÿï¼‰ */
    .wheelFadeTop, .wheelFadeBottom{
      pointer-events: none;
      position: absolute;
      left: 12px;
      right: 12px;
      height: 44px;
      z-index: 2;
    }
    .wheelFadeTop{
      top: 12px;
      background: linear-gradient(to bottom, var(--wheel-fade), rgba(255,255,255,0));
    }
    .wheelFadeBottom{
      bottom: 2px;
      background: linear-gradient(to top, var(--wheel-fade), rgba(255,255,255,0));
    }
    body.dark .wheelFadeTop{
      background: linear-gradient(to bottom, var(--wheel-fade-dark), rgba(15,17,21,0));
    }
    body.dark .wheelFadeBottom{
      background: linear-gradient(to top, var(--wheel-fade-dark), rgba(15,17,21,0));
    }

    /* ä¸­å¤®ã®é¸æŠæ  */
    .wheelCenterLine{
      pointer-events: none;
      position: absolute;
      left: 12px;
      right: 12px;
      top: calc(12px + (var(--wheel-item-h) * 3));
      height: var(--wheel-item-h);
      border-top: 1px solid rgba(100,116,139,0.35);
      border-bottom: 1px solid rgba(100,116,139,0.35);
      border-radius: 14px;
      z-index: 3;
    }

    .wheelList{
      position: relative;
      padding: calc(var(--wheel-item-h) * 3) 0; /* ä¸Šä¸‹ã«ä½™ç™½ï¼ˆä¸­å¤®åˆã‚ã›ï¼‰ */
      margin: 0;
      list-style: none;
    }

    .wheelItem{
      height: var(--wheel-item-h);
      display:flex;
      align-items:center;
      justify-content: center;
      scroll-snap-align: center;
      font-size: 18px;
      user-select: none;
      transform-style: preserve-3d;
      perspective: 700px;
      padding: 0 14px;
    }

    .wheelItemInner{
      width: 100%;
      max-width: 92%;
      text-align: center;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid transparent;
      line-height: 1.15;
      word-break: break-word;
      overflow-wrap: anywhere;
      transition: transform .08s linear, opacity .08s linear, border-color .08s linear, background .08s linear;
    }

    .wheelItemInner .sub{
      display:block;
      font-size: 12px;
      opacity: .70;
      margin-top: 2px;
    }

    .wheelFooter{
      display:flex;
      gap:10px;
      padding: 12px;
      border-top: 1px solid var(--bd);
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    body.dark .wheelFooter{ border-top-color: var(--bd-dark); }

    .wheelHint{
      font-size: 12px;
      opacity: .75;
      padding: 0 12px 10px;
      user-select: none;
    }

    /* ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§é¸æŠã—ã‚„ã™ã */
    .wheelItemInner:active{
      transform: translateZ(0) scale(0.99);
    }
  </style>
</head>

<body>
  <div class="card">

    <h1 id="pageTitle" class="page-title"></h1>

    <div class="topbar">
      <div class="badge" id="progress">0 / 0</div>

      <div class="topbar-right">
        <button id="resetBtn" class="small reviewUI" type="button">Reset</button>
        <button class="small reviewUI pressWhite" id="clearWrongBtn" type="button">å¾©ç¿’Reset</button>
      </div>
    </div>

    <div class="row">
      <label class="pill togglePill reviewUI" for="wrongOnlyToggle">
        <input type="checkbox" id="wrongOnlyToggle" />
        å¾©ç¿’ <span class="count" id="wrongCount">(0)</span>
      </label>

      <button class="small toggle" id="audioToggle" type="button">ğŸ”Š</button>
      <button class="small toggle" id="themeToggle" type="button">ğŸŒ™</button>
      <button class="small toggle" id="orderToggle" type="button">ğŸ”€ ãƒ©ãƒ³ãƒ€ãƒ </button>

      <!-- â˜…è¿½åŠ ï¼šãƒ›ã‚¤ãƒ¼ãƒ«æ¤œç´¢ãƒœã‚¿ãƒ³ -->
      <button class="small toggle" id="wheelOpenBtn" type="button">ğŸ¡ æ¢ã™</button>
    </div>

    <div class="row">
      <div class="rangeStack">
        <label class="badge" style="display:flex; gap:8px; align-items:center;">
          No
          <input id="rangeFrom" class="rangeInput" type="number" min="1" value="1">
          ã€œ
          <input id="rangeTo" class="rangeInput" type="number" min="1" value="10">
        </label>
        <span class="word-no">No</span>
        <span id="wordNumHeader" class="word-num-header"></span>
      </div>
    </div>

    <div class="displayArea">
      <div class="word">
        <span class="word-text" id="wordText">ï¼ˆreadingâ€¦ï¼‰</span>
      </div>
      <div class="meaning" id="meaning"></div>
    </div>

    <div class="btns">
      <button class="primary" id="nextBtn" type="button">ã¯ã˜ã‚ã‚‹</button>
    </div>

    <div class="missBox reviewUI" id="missBox">
      <input type="checkbox" id="missToggle">
      <label class="label" for="missToggle">å¾©ç¿’ãƒªã‚¹ãƒˆã«è¿½åŠ </label>
    </div>

    <div class="btns">
      <button id="speakBtn" type="button">ğŸ”Š ç™ºéŸ³</button>
    </div>

  </div>

  <!-- =========================================================
       ğŸ¡ 3D ãƒ›ã‚¤ãƒ¼ãƒ« ãƒ¢ãƒ¼ãƒ€ãƒ«
  ========================================================== -->
  <div class="modalOverlay" id="wheelOverlay" aria-hidden="true">
    <div class="modalSheet" role="dialog" aria-modal="true" aria-labelledby="wheelTitle">
      <div class="modalHeader">
        <div class="modalTitle" id="wheelTitle">ğŸ¡ å˜èªã‚’æ¢ã™ï¼ˆãƒ›ã‚¤ãƒ¼ãƒ«ï¼‰</div>
        <button class="mini" id="wheelCloseBtn" type="button">é–‰ã˜ã‚‹</button>
      </div>

      <div class="wheelSearchRow">
        <input class="wheelSearch" id="wheelSearchInput" type="search" placeholder="ä¾‹: cre / mean / inc ...ï¼ˆè‹±èªï¼‰" autocomplete="off" />
        <button class="mini" id="wheelClearSearchBtn" type="button">ã‚¯ãƒªã‚¢</button>
      </div>

      <div class="wheelArea">
        <div class="wheelFadeTop"></div>
        <div class="wheelFadeBottom"></div>
        <div class="wheelCenterLine"></div>

        <div class="wheelViewport" id="wheelViewport">
          <ul class="wheelList" id="wheelList"></ul>
        </div>
      </div>

      <div class="wheelHint" id="wheelHint"></div>

      <div class="wheelFooter">
        <button class="mini" id="wheelJumpBtn" type="button">ã“ã®å˜èªã¸ç§»å‹•</button>
      </div>
    </div>
  </div>

<script>
const VOCAB = [
  { en: "create", ja: "ã‚’å‰µã‚Šå‡ºã™ï¼›ã‚’å¼•ãèµ·ã“ã™" },
  { en: "increase", ja: "å¢—åŠ ã™ã‚‹ï¼ˆâ‡” decrease â‡’ 223ï¼‰ï¼›ã‚’å¢—ã‚„ã™" },
  { en: "improve", ja: "ã‚’å‘ä¸Šã•ã›ã‚‹ï¼›ã‚ˆããªã‚‹" },
  { en: "mean", ja: "ã‚’æ„å‘³ã™ã‚‹ï¼›ï¼ˆ...ã™ã‚‹ï¼‰ã¤ã‚‚ã‚Šã§ã‚ã‚‹ï¼ˆto doï¼‰" },
  { en: "own", ja: "ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ï¼›ï¼ˆäº‹å®Ÿãƒ»ç½ªãªã©ï¼‰ã‚’èªã‚ã‚‹" },
  { en: "include", ja: "ã‚’å«ã‚€ï¼ˆâ‡” exclude â‡’ 1009ï¼‰" },
];

const KEY_AUDIO       = "vocab_app_audio_on_v1";
const KEY_WRONG_SET   = "vocab_wrong_set_v1";
const KEY_WRONG_ONLY  = "vocab_wrong_only_v1";
const KEY_THEME       = "vocab_theme_v1";
const KEY_RANGE       = "vocab_range_v1";
const KEY_ORDER_MODE  = "vocab_order_mode_v1";

/* â˜…è¿½åŠ ï¼šãƒ›ã‚¤ãƒ¼ãƒ«ã®æ¤œç´¢æ–‡å­— */
const KEY_WHEEL_QUERY = "vocab_wheel_query_v1";

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function saveJSON(key, obj){ localStorage.setItem(key, JSON.stringify(obj)); }
function loadJSON(key){
  try{
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : null;
  }catch{ return null; }
}
function clamp(n, min, max){
  return Math.max(min, Math.min(max, n));
}

function loadRange(){
  const saved = loadJSON(KEY_RANGE);
  const maxN = VOCAB.length;

  let from = 1;
  let to = Math.min(10, maxN);

  if (saved && typeof saved.from === "number" && typeof saved.to === "number"){
    from = saved.from;
    to = saved.to;
  }

  from = clamp(Math.floor(from), 1, maxN);
  to   = clamp(Math.floor(to),   1, maxN);
  if (from > to) [from, to] = [to, from];

  return { from, to };
}
function saveRange(r){
  saveJSON(KEY_RANGE, r);
}

function loadTheme(){
  const v = localStorage.getItem(KEY_THEME);
  return (v === "dark" || v === "light") ? v : "light";
}
function saveTheme(theme){
  localStorage.setItem(KEY_THEME, theme);
}
function applyTheme(theme){
  const isDark = theme === "dark";
  document.body.classList.toggle("dark", isDark);
  const btn = document.getElementById("themeToggle");
  if (btn) btn.textContent = isDark ? "â˜€ï¸" : "ğŸŒ™";
}

/* å‡ºé¡Œé †ãƒ¢ãƒ¼ãƒ‰ */
function loadOrderMode(){
  const v = localStorage.getItem(KEY_ORDER_MODE);
  return (v === "asc" || v === "random") ? v : "random";
}
function saveOrderMode(mode){
  localStorage.setItem(KEY_ORDER_MODE, mode);
}
function updateOrderUI(){
  const mode = loadOrderMode();
  const btn = document.getElementById("orderToggle");
  if (!btn) return;
  btn.textContent = (mode === "random") ? "ğŸ”€" : "ğŸ”¢";
}

function pickEnglishVoice(){
  const voices = speechSynthesis.getVoices();
  const preferred =
    voices.find(v => /Samantha|Karen/i.test(v.name || "")) ||
    voices.find(v => (v.lang || "").toLowerCase().startsWith("en-us")) ||
    voices.find(v => (v.lang || "").toLowerCase().startsWith("en-gb")) ||
    voices.find(v => (v.lang || "").toLowerCase().startsWith("en")) ||
    null;
  return preferred;
}

function loadAudioOn(){
  const v = localStorage.getItem(KEY_AUDIO);
  return v === null ? true : v === "1";
}
function saveAudioOn(on){
  localStorage.setItem(KEY_AUDIO, on ? "1" : "0");
}
function updateAudioUI(){
  const on = loadAudioOn();
  document.getElementById("audioToggle").textContent = on ? "ğŸ”Š" : "ğŸ”‡";
}

function speakEnglish(text){
  if (!window.speechSynthesis) return;
  if (!loadAudioOn()) return;

  try{ speechSynthesis.cancel(); }catch{}
  const u = new SpeechSynthesisUtterance(String(text));
  const voice = pickEnglishVoice();
  u.lang = voice?.lang || "en-US";
  if (voice) u.voice = voice;
  u.rate = 1.0;
  u.pitch = 1.0;
  speechSynthesis.speak(u);
}

function loadWrongSet(){
  const arr = loadJSON(KEY_WRONG_SET);
  return new Set(Array.isArray(arr) ? arr : []);
}
function saveWrongSet(set){
  saveJSON(KEY_WRONG_SET, Array.from(set));
}
function updateWrongCountUI(){
  const set = loadWrongSet();
  document.getElementById("wrongCount").textContent = `:${set.size}`;
}

function loadWrongOnly(){
  return localStorage.getItem(KEY_WRONG_ONLY) === "1";
}
function saveWrongOnly(on){
  localStorage.setItem(KEY_WRONG_ONLY, on ? "1" : "0");
}

function getActiveStateKey(){
  const { from, to } = loadRange();
  const base = loadWrongOnly() ? "wrong" : "all";
  return `vocab_state_${base}_r${from}-${to}_v1`;
}

function getPoolIndices(){
  const { from, to } = loadRange();
  const start = from - 1;
  const end   = to - 1;

  const ranged = [];
  for (let i = start; i <= end; i++){
    if (i >= 0 && i < VOCAB.length) ranged.push(i);
  }

  if (!loadWrongOnly()) return ranged;

  const set = loadWrongSet();
  return ranged.filter(i => set.has(VOCAB[i].en));
}

function freshStateForPool(poolIdxs){
  const mode = loadOrderMode();
  let order = [...Array(poolIdxs.length).keys()];

  if (mode === "random"){
    order = shuffle(order);
  } else {
    order.sort((a, b) => poolIdxs[a] - poolIdxs[b]);
  }

  return { poolIdxs, order, index: 0, phase: 0 };
}

function loadState(){
  const key = getActiveStateKey();
  const st = loadJSON(key);
  if (!st) return null;
  if (!Array.isArray(st.poolIdxs) || !Array.isArray(st.order)) return null;
  if (typeof st.index !== "number" || typeof st.phase !== "number") return null;
  if (st.phase !== 0 && st.phase !== 1) return null;

  const poolNow = getPoolIndices();
  if (st.poolIdxs.length !== poolNow.length) return null;

  return st;
}
function saveState(st){
  const key = getActiveStateKey();
  saveJSON(key, st);
}

function getCurrentItem(st){
  if (!st.poolIdxs.length) return null;
  const poolIndex = st.poolIdxs[ st.order[st.index] ];
  return { item: VOCAB[poolIndex], vocabIndex: poolIndex };
}

function setUI(st){
  const wordNumHeaderEl = document.getElementById("wordNumHeader");
  const wordTextEl = document.getElementById("wordText");
  const meaningEl = document.getElementById("meaning");
  const progressEl = document.getElementById("progress");
  const btn = document.getElementById("nextBtn");

  const missBox = document.getElementById("missBox");
  const missToggle = document.getElementById("missToggle");

  if (!st.poolIdxs.length){
    wordNumHeaderEl.textContent = "";
    wordTextEl.textContent = "ï¼ˆå‡ºé¡ŒãŒã‚ã‚Šã¾ã›ã‚“ï¼‰";
    meaningEl.textContent = "ç¯„å›²ã‚’åºƒã’ã‚‹ã‹ã€ã€Œå¾©ç¿’é–‹å§‹ã€ã‚’OFFã«ã™ã‚‹ã‹ã€å¾©ç¿’ãƒªã‚¹ãƒˆã‚’ç™»éŒ²ã—ã¦ã­";
    progressEl.textContent = "0 / 0";
    btn.textContent = "ã¯ã˜ã‚ã‚‹";
    missBox.classList.remove("show");
    missToggle.checked = false;
    return;
  }

  if (st.index >= st.poolIdxs.length){
    st = freshStateForPool(getPoolIndices());
    saveState(st);
  }

  const cur = getCurrentItem(st);
  const current = cur.item;
  const number = cur.vocabIndex + 1;

  progressEl.textContent = `${st.index + 1} / ${st.poolIdxs.length}`;

  const wrongSet = loadWrongSet();
  missToggle.checked = wrongSet.has(current.en);

  wordNumHeaderEl.textContent = number;
  wordTextEl.textContent = current.en;

  if (st.phase === 0){
    meaningEl.textContent = "";
    btn.textContent = "æ—¥æœ¬èªè¨³ã‚’ç¢ºèª ï¼ˆç­”ãˆåˆã‚ã›ï¼‰";
    missBox.classList.remove("show");
    speakEnglish(current.en);
  } else {
    meaningEl.textContent = current.ja;
    btn.textContent = "æ­£è§£ã ã£ãŸã‹ãªï¼Ÿ æ¬¡ã®å˜èªã¸ï¼";
    missBox.classList.add("show");
  }
}

function nextAction(){
  let st = loadState();
  if (!st){
    const pool = getPoolIndices();
    st = freshStateForPool(pool);
    saveState(st);
    setUI(st);
    return;
  }

  if (st.phase === 0){
    st.phase = 1;
  } else {
    st.phase = 0;
    st.index += 1;
  }
  saveState(st);
  setUI(st);
}

function resetAll(){
  try{ speechSynthesis.cancel(); }catch{}
  const pool = getPoolIndices();
  const st = freshStateForPool(pool);
  saveState(st);
  setUI(st);
}

/* =========================================================
   ğŸ¡ ãƒ›ã‚¤ãƒ¼ãƒ«æ©Ÿèƒ½
========================================================= */
const wheel = {
  overlay: null,
  viewport: null,
  list: null,
  search: null,
  hint: null,
  btnJump: null,
  closeBtn: null,
  clearBtn: null,
  openBtn: null,

  pool: [],
  filtered: [],
  activeIndex: 0,
  raf: 0,
};

function loadWheelQuery(){
  const v = localStorage.getItem(KEY_WHEEL_QUERY);
  return (typeof v === "string") ? v : "";
}
function saveWheelQuery(q){
  localStorage.setItem(KEY_WHEEL_QUERY, q);
}

/* ç¾åœ¨ãƒ—ãƒ¼ãƒ«ã‚’ã€ãƒ›ã‚¤ãƒ¼ãƒ«è¡¨ç¤ºç”¨é…åˆ—ã« */
function buildWheelPool(){
  const poolIdxs = getPoolIndices(); // vocabIndex ã®é…åˆ—
  // è¡¨ç¤ºé †ï¼šå‡ºé¡Œé †ãƒ¢ãƒ¼ãƒ‰ã«åˆã‚ã›ã‚‹ï¼ˆrandom/ascï¼‰
  const mode = loadOrderMode();

  let arranged = poolIdxs.slice();
  if (mode === "random"){
    // ãƒ›ã‚¤ãƒ¼ãƒ«ã¯ã€Œæ¢ã™ã€ç”¨é€”ãªã®ã§ã€ãƒ©ãƒ³ãƒ€ãƒ ã¯ä½¿ã„ã«ãã„ã“ã¨ãŒå¤šã„
    // ãŸã ã—ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¨­å®šã«åˆã‚ã›ã‚‹æ–¹é‡ã®ãŸã‚ã€ã“ã“ã¯ã€Œè‹±èªæ˜‡é †ã€ã«å›ºå®šã«ã™ã‚‹ã¨é•å’Œæ„ŸãŒå‡ºã‚‹ã€‚
    // -> ãƒ©ãƒ³ãƒ€ãƒ ã®æ™‚ã¯ã€Œç•ªå·æ˜‡é †ã€ã«ã™ã‚‹ï¼ˆæ¢ã—ã‚„ã™ã•å„ªå…ˆï¼‰
    arranged.sort((a,b)=>a-b);
  } else {
    arranged.sort((a,b)=>a-b);
  }

  return arranged.map(vocabIndex => ({
    vocabIndex,
    en: VOCAB[vocabIndex].en,
    ja: VOCAB[vocabIndex].ja
  }));
}

function wheelFilter(list, q){
  const query = String(q || "").trim().toLowerCase();
  if (!query) return list.slice();

  // å‰æ–¹ä¸€è‡´å„ªå…ˆ â†’ éƒ¨åˆ†ä¸€è‡´
  const starts = [];
  const contains = [];
  for (const it of list){
    const s = it.en.toLowerCase();
    if (s.startsWith(query)) starts.push(it);
    else if (s.includes(query)) contains.push(it);
  }
  return starts.concat(contains);
}

function wheelRender(){
  const q = wheel.search.value;
  saveWheelQuery(q);

  wheel.pool = buildWheelPool();
  wheel.filtered = wheelFilter(wheel.pool, q);

  wheel.list.innerHTML = "";

  if (wheel.filtered.length === 0){
    const li = document.createElement("li");
    li.className = "wheelItem";
    li.innerHTML = `<div class="wheelItemInner" style="opacity:.75;border-color:transparent;">ä¸€è‡´ã™ã‚‹å˜èªãŒã‚ã‚Šã¾ã›ã‚“</div>`;
    wheel.list.appendChild(li);
    wheel.hint.textContent = "æ¤œç´¢æ¡ä»¶ã‚’å¤‰ãˆã¦ã¿ã¦ãã ã•ã„ã€‚";
    wheel.activeIndex = 0;
    wheelApply3D();
    return;
  }

  for (let i=0; i<wheel.filtered.length; i++){
    const it = wheel.filtered[i];
    const li = document.createElement("li");
    li.className = "wheelItem";
    li.dataset.index = String(i);
    li.innerHTML = `
      <div class="wheelItemInner">
        ${escapeHtml(it.en)}
        <span class="sub">No ${it.vocabIndex + 1}</span>
      </div>
    `;
    // ã‚¿ãƒƒãƒ—ã§ãã®é …ç›®ã¸ã‚¹ãƒŠãƒƒãƒ—
    li.addEventListener("click", () => {
      wheelScrollToIndex(i, true);
    });
    wheel.list.appendChild(li);
  }

  wheel.hint.textContent = `è¡¨ç¤º: ${wheel.filtered.length} ä»¶ï¼ˆç¯„å›²/å¾©ç¿’è¨­å®šã«é€£å‹•ï¼‰`;

  // åˆæœŸä½ç½®ï¼šç¾åœ¨è¡¨ç¤ºä¸­ã®å˜èªãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰ãã“ã¸
  const st = loadState();
  const cur = st ? getCurrentItem(st) : null;
  let idx = 0;
  if (cur){
    const vi = cur.vocabIndex;
    const found = wheel.filtered.findIndex(x => x.vocabIndex === vi);
    if (found >= 0) idx = found;
  }

  wheel.activeIndex = clamp(idx, 0, wheel.filtered.length - 1);
  // æç”»å¾Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
  requestAnimationFrame(() => {
    wheelScrollToIndex(wheel.activeIndex, false);
    wheelApply3D();
  });
}

function wheelScrollToIndex(i, smooth){
  const items = wheel.list.querySelectorAll(".wheelItem");
  if (!items.length) return;

  const idx = clamp(i, 0, items.length - 1);
  const target = items[idx];

  const top = target.offsetTop + (target.offsetHeight/2) - (wheel.viewport.clientHeight/2);
  wheel.viewport.scrollTo({ top, behavior: smooth ? "smooth" : "auto" });
  wheel.activeIndex = idx;
  wheelApply3D();
}

function wheelPickNearest(){
  const items = wheel.list.querySelectorAll(".wheelItem");
  if (!items.length) return 0;

  const centerY = wheel.viewport.scrollTop + wheel.viewport.clientHeight/2;

  let best = 0;
  let bestDist = Infinity;

  items.forEach((el, i) => {
    const y = el.offsetTop + el.offsetHeight/2;
    const d = Math.abs(y - centerY);
    if (d < bestDist){
      bestDist = d;
      best = i;
    }
  });
  return best;
}

function wheelSnap(){
  const i = wheelPickNearest();
  wheel.activeIndex = i;
  wheelScrollToIndex(i, true);
}

function wheelApply3D(){
  const items = wheel.list.querySelectorAll(".wheelItem");
  if (!items.length) return;

  const centerY = wheel.viewport.scrollTop + wheel.viewport.clientHeight/2;

  items.forEach((row, i) => {
    const y = row.offsetTop + row.offsetHeight/2;
    const delta = (y - centerY) / (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--wheel-item-h")) || 44);

    // -3 .. 3 ã‚ãŸã‚Šã‚’æƒ³å®š
    const clamped = clamp(delta, -4, 4);
    const angle = clamped * 12;         // å›è»¢è§’
    const z = Math.max(0, 1 - Math.abs(clamped)/4); // ä¸­å¤®ã»ã©å‰ã«
    const scale = 0.92 + z * 0.12;      // ä¸­å¤®ãŒå°‘ã—å¤§ãã„
    const opacity = 0.25 + z * 0.75;

    const inner = row.querySelector(".wheelItemInner");
    if (!inner) return;

    inner.style.transform = `translateZ(${z * 18}px) rotateX(${angle}deg) scale(${scale})`;
    inner.style.opacity = String(opacity);

    // ä¸­å¤®ä»˜è¿‘ã‚’å¼·èª¿
    if (Math.abs(clamped) < 0.35){
      inner.style.borderColor = "rgba(100,116,139,0.25)";
      inner.style.background = "rgba(100,116,139,0.06)";
    } else {
      inner.style.borderColor = "transparent";
      inner.style.background = "transparent";
    }
  });
}

function wheelOpen(){
  wheel.overlay.classList.add("show");
  wheel.overlay.setAttribute("aria-hidden", "false");

  // ç›´å‰ã®æ¤œç´¢æ–‡å­—ã‚’å¾©å…ƒ
  wheel.search.value = loadWheelQuery() || "";
  wheelRender();

  // èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åœæ­¢ï¼ˆiPhoneå¯¾ç­–ï¼‰
  document.body.style.overflow = "hidden";

  // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
  setTimeout(() => {
    wheel.search.focus({ preventScroll: true });
  }, 120);
}

function wheelClose(){
  wheel.overlay.classList.remove("show");
  wheel.overlay.setAttribute("aria-hidden", "true");
  document.body.style.overflow = "";
}

function wheelJumpToSelected(){
  if (!wheel.filtered.length) return;
  const picked = wheel.filtered[clamp(wheel.activeIndex, 0, wheel.filtered.length - 1)];
  if (!picked) return;

  // ç¾åœ¨ã® state ã‚’èª­ã¿ã€åŒã˜ poolIdxs ã§ order ã‚’ä½œã‚Šç›´ã—ã€
  // picked.vocabIndex ãŒ st.index ã§æŒ‡ã™ã‚ˆã†ã«ã™ã‚‹
  const poolIdxs = getPoolIndices();
  if (!poolIdxs.length) return;

  const st = loadState() || freshStateForPool(poolIdxs);

  // ç¾åœ¨ã® pool ã¨åˆã£ã¦ãªã„å ´åˆã¯ä½œã‚Šç›´ã™
  const poolNow = getPoolIndices();
  if (!Array.isArray(st.poolIdxs) || st.poolIdxs.length !== poolNow.length){
    st.poolIdxs = poolNow;
    st.order = freshStateForPool(poolNow).order;
  }

  // st.order ã®ä¸­ã‹ã‚‰ã€picked.vocabIndex ã®ä½ç½®ã‚’æ¢ã™
  let foundIndex = -1;
  for (let i=0; i<st.order.length; i++){
    const poolIndex = st.poolIdxs[ st.order[i] ];
    if (poolIndex === picked.vocabIndex){
      foundIndex = i;
      break;
    }
  }

  if (foundIndex === -1){
    // å¿µã®ãŸã‚ï¼špoolãŒå¤‰ã‚ã£ãŸç­‰
    st.poolIdxs = poolNow;
    st.order = freshStateForPool(poolNow).order;
    for (let i=0; i<st.order.length; i++){
      const poolIndex = st.poolIdxs[ st.order[i] ];
      if (poolIndex === picked.vocabIndex){
        foundIndex = i;
        break;
      }
    }
  }

  if (foundIndex >= 0){
    st.index = foundIndex;
    st.phase = 0; // ãƒ†ã‚¹ãƒˆé–‹å§‹çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆè‹±èªã®ã¿ï¼‰
    saveState(st);
    setUI(st);
    try{ speakEnglish(picked.en); }catch{}
  }

  wheelClose();
}

/* HTML escape */
function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* =========================================================
   init
========================================================= */
function init(){
  document.getElementById("pageTitle").textContent = document.title;

  if (!VOCAB.length){
    document.getElementById("wordText").textContent = "VOCABãŒç©ºã§ã™";
    return;
  }

  applyTheme(loadTheme());
  document.getElementById("themeToggle").addEventListener("click", () => {
    const now = loadTheme();
    const next = (now === "dark") ? "light" : "dark";
    saveTheme(next);
    applyTheme(next);
    // ãƒ›ã‚¤ãƒ¼ãƒ«ã®ãƒ•ã‚§ãƒ¼ãƒ‰ãªã©ã¯CSSã§å¯¾å¿œæ¸ˆã¿
  });

  updateOrderUI();

  if (window.speechSynthesis){
    speechSynthesis.onvoiceschanged = () => updateAudioUI();
    setTimeout(updateAudioUI, 200);
    setTimeout(updateAudioUI, 800);
  } else {
    document.getElementById("audioToggle").disabled = true;
    document.getElementById("speakBtn").disabled = true;
  }

  const rangeFromEl = document.getElementById("rangeFrom");
  const rangeToEl   = document.getElementById("rangeTo");
  const r = loadRange();
  rangeFromEl.value = r.from;
  rangeToEl.value   = r.to;

  function onRangeChange(){
    let from = parseInt(rangeFromEl.value, 10);
    let to   = parseInt(rangeToEl.value, 10);
    if (!Number.isFinite(from)) from = 1;
    if (!Number.isFinite(to)) to = VOCAB.length;

    from = clamp(from, 1, VOCAB.length);
    to   = clamp(to,   1, VOCAB.length);
    if (from > to) [from, to] = [to, from];

    rangeFromEl.value = from;
    rangeToEl.value   = to;

    saveRange({ from, to });

    const pool = getPoolIndices();
    const st = freshStateForPool(pool);
    saveState(st);

    updateWrongCountUI();
    setUI(st);

    // ãƒ›ã‚¤ãƒ¼ãƒ«å´ã‚‚æ›´æ–°ã—ã‚„ã™ã„ã‚ˆã†ã«
    if (wheel.overlay.classList.contains("show")){
      wheelRender();
    }
  }

  rangeFromEl.addEventListener("change", onRangeChange);
  rangeToEl.addEventListener("change", onRangeChange);

  updateWrongCountUI();

  const wrongOnlyToggle = document.getElementById("wrongOnlyToggle");
  wrongOnlyToggle.checked = loadWrongOnly();
  wrongOnlyToggle.addEventListener("change", () => {
    saveWrongOnly(wrongOnlyToggle.checked);

    const pool = getPoolIndices();
    const st = freshStateForPool(pool);
    saveState(st);

    updateWrongCountUI();
    setUI(st);

    if (wheel.overlay.classList.contains("show")){
      wheelRender();
    }
  });

  document.getElementById("missToggle").addEventListener("change", (e) => {
    const st = loadState();
    if (!st) return;
    const cur = getCurrentItem(st);
    if (!cur) return;

    const set = loadWrongSet();
    if (e.target.checked) set.add(cur.item.en);
    else set.delete(cur.item.en);

    saveWrongSet(set);
    updateWrongCountUI();

    if (wheel.overlay.classList.contains("show")){
      wheelRender();
    }
  });

  document.getElementById("clearWrongBtn").addEventListener("click", () => {
    saveWrongSet(new Set());
    updateWrongCountUI();

    const pool = getPoolIndices();
    const st = freshStateForPool(pool);
    saveState(st);
    setUI(st);

    if (wheel.overlay.classList.contains("show")){
      wheelRender();
    }
  });

  const pool = getPoolIndices();
  let st = loadState();
  if (!st) st = freshStateForPool(pool);
  saveState(st);
  setUI(st);

  document.getElementById("nextBtn").addEventListener("click", nextAction);
  document.getElementById("resetBtn").addEventListener("click", resetAll);

  document.getElementById("speakBtn").addEventListener("click", () => {
    const st2 = loadState();
    if (!st2) return;
    const cur = getCurrentItem(st2);
    if (!cur) return;
    speakEnglish(cur.item.en);
  });

  document.getElementById("audioToggle").addEventListener("click", () => {
    const on = loadAudioOn();
    saveAudioOn(!on);
    updateAudioUI();

    const st2 = loadState();
    if (st2 && st2.phase === 0){
      const cur = getCurrentItem(st2);
      if (cur) speakEnglish(cur.item.en);
    }
  });

  document.getElementById("orderToggle").addEventListener("click", () => {
    const now = loadOrderMode();
    const next = (now === "random") ? "asc" : "random";
    saveOrderMode(next);
    updateOrderUI();

    const pool2 = getPoolIndices();
    const st2 = freshStateForPool(pool2);
    saveState(st2);
    setUI(st2);

    if (wheel.overlay.classList.contains("show")){
      wheelRender();
    }
  });

  /* ===== ğŸ¡ ãƒ›ã‚¤ãƒ¼ãƒ«è¦ç´ ã‚’ç´ã¥ã‘ ===== */
  wheel.overlay = document.getElementById("wheelOverlay");
  wheel.viewport = document.getElementById("wheelViewport");
  wheel.list = document.getElementById("wheelList");
  wheel.search = document.getElementById("wheelSearchInput");
  wheel.hint = document.getElementById("wheelHint");
  wheel.btnJump = document.getElementById("wheelJumpBtn");
  wheel.closeBtn = document.getElementById("wheelCloseBtn");
  wheel.clearBtn = document.getElementById("wheelClearSearchBtn");
  wheel.openBtn = document.getElementById("wheelOpenBtn");

  wheel.openBtn.addEventListener("click", wheelOpen);
  wheel.closeBtn.addEventListener("click", wheelClose);
  wheel.btnJump.addEventListener("click", wheelJumpToSelected);
  wheel.clearBtn.addEventListener("click", () => {
    wheel.search.value = "";
    saveWheelQuery("");
    wheelRender();
  });

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤èƒŒæ™¯ã‚¿ãƒƒãƒ—ã§é–‰ã˜ã‚‹ï¼ˆã‚·ãƒ¼ãƒˆè‡ªä½“ã¯é–‰ã˜ãªã„ï¼‰
  wheel.overlay.addEventListener("click", (e) => {
    if (e.target === wheel.overlay) wheelClose();
  });

  // ESCã§é–‰ã˜ã‚‹ï¼ˆPCå‘ã‘ï¼‰
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && wheel.overlay.classList.contains("show")){
      wheelClose();
    }
  });

  // æ¤œç´¢ã§å†æç”»ï¼ˆè»½ã‚ï¼‰
  let t = 0;
  wheel.search.addEventListener("input", () => {
    clearTimeout(t);
    t = setTimeout(wheelRender, 80);
  });

  // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã¯3Dæ›´æ–°ã€æ­¢ã¾ã£ãŸã‚‰ã‚¹ãƒŠãƒƒãƒ—
  let snapTimer = 0;
  wheel.viewport.addEventListener("scroll", () => {
    if (wheel.raf) cancelAnimationFrame(wheel.raf);
    wheel.raf = requestAnimationFrame(wheelApply3D);

    clearTimeout(snapTimer);
    snapTimer = setTimeout(() => {
      // è¡¨ç¤ºãŒã‚ã‚‹ã¨ãã ã‘
      if (wheel.overlay.classList.contains("show")){
        wheelSnap();
      }
    }, 140);
  }, { passive: true });

  // ã€Œç§»å‹•ã€ãƒœã‚¿ãƒ³ã®ä»£ã‚ã‚Šã«ã€ãƒ›ã‚¤ãƒ¼ãƒ«ä¸­å¤®ä»˜è¿‘ã‚’ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§æ±ºå®šã—ãŸã„å ´åˆã®ä¿é™ºï¼ˆä»Šå›ã¯ç„¡ã—ï¼‰
  // wheel.list.addEventListener("dblclick", wheelJumpToSelected);
}

init();
</script>
</body>
</html>
